// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_message_2eproto__INCLUDED
#define PROTOBUF_message_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsJoinMeImpl();
void InitDefaultsJoinMe();
void InitDefaultsJoinImpl();
void InitDefaultsJoin();
void InitDefaultsNodeImpl();
void InitDefaultsNode();
void InitDefaultsListImpl();
void InitDefaultsList();
void InitDefaultsRoutingUpdate_RoutingEntryImpl();
void InitDefaultsRoutingUpdate_RoutingEntry();
void InitDefaultsRoutingUpdateImpl();
void InitDefaultsRoutingUpdate();
void InitDefaultsAllStateUpdateImpl();
void InitDefaultsAllStateUpdate();
void InitDefaultsGetValImpl();
void InitDefaultsGetVal();
void InitDefaultsGetValResponseImpl();
void InitDefaultsGetValResponse();
void InitDefaultsSetValImpl();
void InitDefaultsSetVal();
void InitDefaultsMessageImpl();
void InitDefaultsMessage();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
void InitDefaultsDeleteNodeImpl();
void InitDefaultsDeleteNode();
void InitDefaultsAddToHashTable_HashMapEntry_DoNotUseImpl();
void InitDefaultsAddToHashTable_HashMapEntry_DoNotUse();
void InitDefaultsAddToHashTableImpl();
void InitDefaultsAddToHashTable();
inline void InitDefaults() {
  InitDefaultsJoinMe();
  InitDefaultsJoin();
  InitDefaultsNode();
  InitDefaultsList();
  InitDefaultsRoutingUpdate_RoutingEntry();
  InitDefaultsRoutingUpdate();
  InitDefaultsAllStateUpdate();
  InitDefaultsGetVal();
  InitDefaultsGetValResponse();
  InitDefaultsSetVal();
  InitDefaultsMessage();
  InitDefaultsResponse();
  InitDefaultsDeleteNode();
  InitDefaultsAddToHashTable_HashMapEntry_DoNotUse();
  InitDefaultsAddToHashTable();
}
}  // namespace protobuf_message_2eproto
namespace message {
class AddToHashTable;
class AddToHashTableDefaultTypeInternal;
extern AddToHashTableDefaultTypeInternal _AddToHashTable_default_instance_;
class AddToHashTable_HashMapEntry_DoNotUse;
class AddToHashTable_HashMapEntry_DoNotUseDefaultTypeInternal;
extern AddToHashTable_HashMapEntry_DoNotUseDefaultTypeInternal _AddToHashTable_HashMapEntry_DoNotUse_default_instance_;
class AllStateUpdate;
class AllStateUpdateDefaultTypeInternal;
extern AllStateUpdateDefaultTypeInternal _AllStateUpdate_default_instance_;
class DeleteNode;
class DeleteNodeDefaultTypeInternal;
extern DeleteNodeDefaultTypeInternal _DeleteNode_default_instance_;
class GetVal;
class GetValDefaultTypeInternal;
extern GetValDefaultTypeInternal _GetVal_default_instance_;
class GetValResponse;
class GetValResponseDefaultTypeInternal;
extern GetValResponseDefaultTypeInternal _GetValResponse_default_instance_;
class Join;
class JoinDefaultTypeInternal;
extern JoinDefaultTypeInternal _Join_default_instance_;
class JoinMe;
class JoinMeDefaultTypeInternal;
extern JoinMeDefaultTypeInternal _JoinMe_default_instance_;
class List;
class ListDefaultTypeInternal;
extern ListDefaultTypeInternal _List_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RoutingUpdate;
class RoutingUpdateDefaultTypeInternal;
extern RoutingUpdateDefaultTypeInternal _RoutingUpdate_default_instance_;
class RoutingUpdate_RoutingEntry;
class RoutingUpdate_RoutingEntryDefaultTypeInternal;
extern RoutingUpdate_RoutingEntryDefaultTypeInternal _RoutingUpdate_RoutingEntry_default_instance_;
class SetVal;
class SetValDefaultTypeInternal;
extern SetValDefaultTypeInternal _SetVal_default_instance_;
}  // namespace message
namespace message {

// ===================================================================

class JoinMe : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.JoinMe) */ {
 public:
  JoinMe();
  virtual ~JoinMe();

  JoinMe(const JoinMe& from);

  inline JoinMe& operator=(const JoinMe& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinMe(JoinMe&& from) noexcept
    : JoinMe() {
    *this = ::std::move(from);
  }

  inline JoinMe& operator=(JoinMe&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JoinMe& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinMe* internal_default_instance() {
    return reinterpret_cast<const JoinMe*>(
               &_JoinMe_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(JoinMe* other);
  friend void swap(JoinMe& a, JoinMe& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinMe* New() const PROTOBUF_FINAL { return New(NULL); }

  JoinMe* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const JoinMe& from);
  void MergeFrom(const JoinMe& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(JoinMe* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:message.JoinMe)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsJoinMeImpl();
};
// -------------------------------------------------------------------

class Join : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Join) */ {
 public:
  Join();
  virtual ~Join();

  Join(const Join& from);

  inline Join& operator=(const Join& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Join(Join&& from) noexcept
    : Join() {
    *this = ::std::move(from);
  }

  inline Join& operator=(Join&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Join& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Join* internal_default_instance() {
    return reinterpret_cast<const Join*>(
               &_Join_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Join* other);
  friend void swap(Join& a, Join& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Join* New() const PROTOBUF_FINAL { return New(NULL); }

  Join* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Join& from);
  void MergeFrom(const Join& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Join* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // int32 row_index = 4;
  void clear_row_index();
  static const int kRowIndexFieldNumber = 4;
  ::google::protobuf::int32 row_index() const;
  void set_row_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.Join)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  ::google::protobuf::int32 row_index_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsJoinImpl();
};
// -------------------------------------------------------------------

class Node : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const PROTOBUF_FINAL { return New(NULL); }

  Node* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nodeID = 1;
  void clear_nodeid();
  static const int kNodeIDFieldNumber = 1;
  const ::std::string& nodeid() const;
  void set_nodeid(const ::std::string& value);
  #if LANG_CXX11
  void set_nodeid(::std::string&& value);
  #endif
  void set_nodeid(const char* value);
  void set_nodeid(const char* value, size_t size);
  ::std::string* mutable_nodeid();
  ::std::string* release_nodeid();
  void set_allocated_nodeid(::std::string* nodeid);

  // string IP = 2;
  void clear_ip();
  static const int kIPFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // string port = 3;
  void clear_port();
  static const int kPortFieldNumber = 3;
  const ::std::string& port() const;
  void set_port(const ::std::string& value);
  #if LANG_CXX11
  void set_port(::std::string&& value);
  #endif
  void set_port(const char* value);
  void set_port(const char* value, size_t size);
  ::std::string* mutable_port();
  ::std::string* release_port();
  void set_allocated_port(::std::string* port);

  // @@protoc_insertion_point(class_scope:message.Node)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nodeid_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr port_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsNodeImpl();
};
// -------------------------------------------------------------------

class List : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.List) */ {
 public:
  List();
  virtual ~List();

  List(const List& from);

  inline List& operator=(const List& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  List(List&& from) noexcept
    : List() {
    *this = ::std::move(from);
  }

  inline List& operator=(List&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const List& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const List* internal_default_instance() {
    return reinterpret_cast<const List*>(
               &_List_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(List* other);
  friend void swap(List& a, List& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline List* New() const PROTOBUF_FINAL { return New(NULL); }

  List* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const List& from);
  void MergeFrom(const List& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(List* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.Node node = 1;
  int node_size() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::message::Node& node(int index) const;
  ::message::Node* mutable_node(int index);
  ::message::Node* add_node();
  ::google::protobuf::RepeatedPtrField< ::message::Node >*
      mutable_node();
  const ::google::protobuf::RepeatedPtrField< ::message::Node >&
      node() const;

  // @@protoc_insertion_point(class_scope:message.List)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::Node > node_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsListImpl();
};
// -------------------------------------------------------------------

class RoutingUpdate_RoutingEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.RoutingUpdate.RoutingEntry) */ {
 public:
  RoutingUpdate_RoutingEntry();
  virtual ~RoutingUpdate_RoutingEntry();

  RoutingUpdate_RoutingEntry(const RoutingUpdate_RoutingEntry& from);

  inline RoutingUpdate_RoutingEntry& operator=(const RoutingUpdate_RoutingEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingUpdate_RoutingEntry(RoutingUpdate_RoutingEntry&& from) noexcept
    : RoutingUpdate_RoutingEntry() {
    *this = ::std::move(from);
  }

  inline RoutingUpdate_RoutingEntry& operator=(RoutingUpdate_RoutingEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingUpdate_RoutingEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingUpdate_RoutingEntry* internal_default_instance() {
    return reinterpret_cast<const RoutingUpdate_RoutingEntry*>(
               &_RoutingUpdate_RoutingEntry_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RoutingUpdate_RoutingEntry* other);
  friend void swap(RoutingUpdate_RoutingEntry& a, RoutingUpdate_RoutingEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingUpdate_RoutingEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutingUpdate_RoutingEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutingUpdate_RoutingEntry& from);
  void MergeFrom(const RoutingUpdate_RoutingEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutingUpdate_RoutingEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .message.List nodeList = 2;
  bool has_nodelist() const;
  void clear_nodelist();
  static const int kNodeListFieldNumber = 2;
  const ::message::List& nodelist() const;
  ::message::List* release_nodelist();
  ::message::List* mutable_nodelist();
  void set_allocated_nodelist(::message::List* nodelist);

  // int32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:message.RoutingUpdate.RoutingEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::message::List* nodelist_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRoutingUpdate_RoutingEntryImpl();
};
// -------------------------------------------------------------------

class RoutingUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.RoutingUpdate) */ {
 public:
  RoutingUpdate();
  virtual ~RoutingUpdate();

  RoutingUpdate(const RoutingUpdate& from);

  inline RoutingUpdate& operator=(const RoutingUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoutingUpdate(RoutingUpdate&& from) noexcept
    : RoutingUpdate() {
    *this = ::std::move(from);
  }

  inline RoutingUpdate& operator=(RoutingUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RoutingUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoutingUpdate* internal_default_instance() {
    return reinterpret_cast<const RoutingUpdate*>(
               &_RoutingUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(RoutingUpdate* other);
  friend void swap(RoutingUpdate& a, RoutingUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoutingUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  RoutingUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoutingUpdate& from);
  void MergeFrom(const RoutingUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoutingUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoutingUpdate_RoutingEntry RoutingEntry;

  // accessors -------------------------------------------------------

  // repeated .message.RoutingUpdate.RoutingEntry routingEntires = 5;
  int routingentires_size() const;
  void clear_routingentires();
  static const int kRoutingEntiresFieldNumber = 5;
  const ::message::RoutingUpdate_RoutingEntry& routingentires(int index) const;
  ::message::RoutingUpdate_RoutingEntry* mutable_routingentires(int index);
  ::message::RoutingUpdate_RoutingEntry* add_routingentires();
  ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >*
      mutable_routingentires();
  const ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >&
      routingentires() const;

  // .message.List leaf = 3;
  bool has_leaf() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 3;
  const ::message::List& leaf() const;
  ::message::List* release_leaf();
  ::message::List* mutable_leaf();
  void set_allocated_leaf(::message::List* leaf);

  // .message.List neighbours = 4;
  bool has_neighbours() const;
  void clear_neighbours();
  static const int kNeighboursFieldNumber = 4;
  const ::message::List& neighbours() const;
  ::message::List* release_neighbours();
  ::message::List* mutable_neighbours();
  void set_allocated_neighbours(::message::List* neighbours);

  // bool buddy = 1;
  void clear_buddy();
  static const int kBuddyFieldNumber = 1;
  bool buddy() const;
  void set_buddy(bool value);

  // bool terminal = 2;
  void clear_terminal();
  static const int kTerminalFieldNumber = 2;
  bool terminal() const;
  void set_terminal(bool value);

  // @@protoc_insertion_point(class_scope:message.RoutingUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry > routingentires_;
  ::message::List* leaf_;
  ::message::List* neighbours_;
  bool buddy_;
  bool terminal_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsRoutingUpdateImpl();
};
// -------------------------------------------------------------------

class AllStateUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.AllStateUpdate) */ {
 public:
  AllStateUpdate();
  virtual ~AllStateUpdate();

  AllStateUpdate(const AllStateUpdate& from);

  inline AllStateUpdate& operator=(const AllStateUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AllStateUpdate(AllStateUpdate&& from) noexcept
    : AllStateUpdate() {
    *this = ::std::move(from);
  }

  inline AllStateUpdate& operator=(AllStateUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AllStateUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AllStateUpdate* internal_default_instance() {
    return reinterpret_cast<const AllStateUpdate*>(
               &_AllStateUpdate_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(AllStateUpdate* other);
  friend void swap(AllStateUpdate& a, AllStateUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AllStateUpdate* New() const PROTOBUF_FINAL { return New(NULL); }

  AllStateUpdate* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AllStateUpdate& from);
  void MergeFrom(const AllStateUpdate& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AllStateUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .message.List routingTable = 2;
  int routingtable_size() const;
  void clear_routingtable();
  static const int kRoutingTableFieldNumber = 2;
  const ::message::List& routingtable(int index) const;
  ::message::List* mutable_routingtable(int index);
  ::message::List* add_routingtable();
  ::google::protobuf::RepeatedPtrField< ::message::List >*
      mutable_routingtable();
  const ::google::protobuf::RepeatedPtrField< ::message::List >&
      routingtable() const;

  // .message.List leaf = 1;
  bool has_leaf() const;
  void clear_leaf();
  static const int kLeafFieldNumber = 1;
  const ::message::List& leaf() const;
  ::message::List* release_leaf();
  ::message::List* mutable_leaf();
  void set_allocated_leaf(::message::List* leaf);

  // .message.List neighbours = 3;
  bool has_neighbours() const;
  void clear_neighbours();
  static const int kNeighboursFieldNumber = 3;
  const ::message::List& neighbours() const;
  ::message::List* release_neighbours();
  ::message::List* mutable_neighbours();
  void set_allocated_neighbours(::message::List* neighbours);

  // @@protoc_insertion_point(class_scope:message.AllStateUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::message::List > routingtable_;
  ::message::List* leaf_;
  ::message::List* neighbours_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsAllStateUpdateImpl();
};
// -------------------------------------------------------------------

class GetVal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.GetVal) */ {
 public:
  GetVal();
  virtual ~GetVal();

  GetVal(const GetVal& from);

  inline GetVal& operator=(const GetVal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVal(GetVal&& from) noexcept
    : GetVal() {
    *this = ::std::move(from);
  }

  inline GetVal& operator=(GetVal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVal* internal_default_instance() {
    return reinterpret_cast<const GetVal*>(
               &_GetVal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GetVal* other);
  friend void swap(GetVal& a, GetVal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVal* New() const PROTOBUF_FINAL { return New(NULL); }

  GetVal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetVal& from);
  void MergeFrom(const GetVal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetVal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // .message.Node node = 2;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 2;
  const ::message::Node& node() const;
  ::message::Node* release_node();
  ::message::Node* mutable_node();
  void set_allocated_node(::message::Node* node);

  // @@protoc_insertion_point(class_scope:message.GetVal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::message::Node* node_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsGetValImpl();
};
// -------------------------------------------------------------------

class GetValResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.GetValResponse) */ {
 public:
  GetValResponse();
  virtual ~GetValResponse();

  GetValResponse(const GetValResponse& from);

  inline GetValResponse& operator=(const GetValResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetValResponse(GetValResponse&& from) noexcept
    : GetValResponse() {
    *this = ::std::move(from);
  }

  inline GetValResponse& operator=(GetValResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetValResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetValResponse* internal_default_instance() {
    return reinterpret_cast<const GetValResponse*>(
               &_GetValResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(GetValResponse* other);
  friend void swap(GetValResponse& a, GetValResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetValResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GetValResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GetValResponse& from);
  void MergeFrom(const GetValResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GetValResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:message.GetValResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsGetValResponseImpl();
};
// -------------------------------------------------------------------

class SetVal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.SetVal) */ {
 public:
  SetVal();
  virtual ~SetVal();

  SetVal(const SetVal& from);

  inline SetVal& operator=(const SetVal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetVal(SetVal&& from) noexcept
    : SetVal() {
    *this = ::std::move(from);
  }

  inline SetVal& operator=(SetVal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetVal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetVal* internal_default_instance() {
    return reinterpret_cast<const SetVal*>(
               &_SetVal_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(SetVal* other);
  friend void swap(SetVal& a, SetVal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetVal* New() const PROTOBUF_FINAL { return New(NULL); }

  SetVal* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SetVal& from);
  void MergeFrom(const SetVal& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SetVal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // string val = 2;
  void clear_val();
  static const int kValFieldNumber = 2;
  const ::std::string& val() const;
  void set_val(const ::std::string& value);
  #if LANG_CXX11
  void set_val(::std::string&& value);
  #endif
  void set_val(const char* value);
  void set_val(const char* value, size_t size);
  ::std::string* mutable_val();
  ::std::string* release_val();
  void set_allocated_val(::std::string* val);

  // .message.Node node = 3;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 3;
  const ::message::Node& node() const;
  ::message::Node* release_node();
  ::message::Node* mutable_node();
  void set_allocated_node(::message::Node* node);

  // bool terminal = 4;
  void clear_terminal();
  static const int kTerminalFieldNumber = 4;
  bool terminal() const;
  void set_terminal(bool value);

  // @@protoc_insertion_point(class_scope:message.SetVal)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr val_;
  ::message::Node* node_;
  bool terminal_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsSetValImpl();
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum MsgCase {
    kJoinMeMsg = 3,
    kJoinMsg = 4,
    kGetValMsg = 5,
    kSetValMsg = 6,
    kRoutingUpdate = 7,
    kAllStateUpdate = 8,
    kGetValResponse = 9,
    kDeleteNode = 10,
    kAddToHashTable = 11,
    MSG_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // .message.Node sender = 2;
  bool has_sender() const;
  void clear_sender();
  static const int kSenderFieldNumber = 2;
  const ::message::Node& sender() const;
  ::message::Node* release_sender();
  ::message::Node* mutable_sender();
  void set_allocated_sender(::message::Node* sender);

  // .message.JoinMe joinMeMsg = 3;
  bool has_joinmemsg() const;
  void clear_joinmemsg();
  static const int kJoinMeMsgFieldNumber = 3;
  const ::message::JoinMe& joinmemsg() const;
  ::message::JoinMe* release_joinmemsg();
  ::message::JoinMe* mutable_joinmemsg();
  void set_allocated_joinmemsg(::message::JoinMe* joinmemsg);

  // .message.Join joinMsg = 4;
  bool has_joinmsg() const;
  void clear_joinmsg();
  static const int kJoinMsgFieldNumber = 4;
  const ::message::Join& joinmsg() const;
  ::message::Join* release_joinmsg();
  ::message::Join* mutable_joinmsg();
  void set_allocated_joinmsg(::message::Join* joinmsg);

  // .message.GetVal getValMsg = 5;
  bool has_getvalmsg() const;
  void clear_getvalmsg();
  static const int kGetValMsgFieldNumber = 5;
  const ::message::GetVal& getvalmsg() const;
  ::message::GetVal* release_getvalmsg();
  ::message::GetVal* mutable_getvalmsg();
  void set_allocated_getvalmsg(::message::GetVal* getvalmsg);

  // .message.SetVal setValMsg = 6;
  bool has_setvalmsg() const;
  void clear_setvalmsg();
  static const int kSetValMsgFieldNumber = 6;
  const ::message::SetVal& setvalmsg() const;
  ::message::SetVal* release_setvalmsg();
  ::message::SetVal* mutable_setvalmsg();
  void set_allocated_setvalmsg(::message::SetVal* setvalmsg);

  // .message.RoutingUpdate routingUpdate = 7;
  bool has_routingupdate() const;
  void clear_routingupdate();
  static const int kRoutingUpdateFieldNumber = 7;
  const ::message::RoutingUpdate& routingupdate() const;
  ::message::RoutingUpdate* release_routingupdate();
  ::message::RoutingUpdate* mutable_routingupdate();
  void set_allocated_routingupdate(::message::RoutingUpdate* routingupdate);

  // .message.AllStateUpdate allStateUpdate = 8;
  bool has_allstateupdate() const;
  void clear_allstateupdate();
  static const int kAllStateUpdateFieldNumber = 8;
  const ::message::AllStateUpdate& allstateupdate() const;
  ::message::AllStateUpdate* release_allstateupdate();
  ::message::AllStateUpdate* mutable_allstateupdate();
  void set_allocated_allstateupdate(::message::AllStateUpdate* allstateupdate);

  // .message.GetValResponse getValResponse = 9;
  bool has_getvalresponse() const;
  void clear_getvalresponse();
  static const int kGetValResponseFieldNumber = 9;
  const ::message::GetValResponse& getvalresponse() const;
  ::message::GetValResponse* release_getvalresponse();
  ::message::GetValResponse* mutable_getvalresponse();
  void set_allocated_getvalresponse(::message::GetValResponse* getvalresponse);

  // .message.DeleteNode deleteNode = 10;
  bool has_deletenode() const;
  void clear_deletenode();
  static const int kDeleteNodeFieldNumber = 10;
  const ::message::DeleteNode& deletenode() const;
  ::message::DeleteNode* release_deletenode();
  ::message::DeleteNode* mutable_deletenode();
  void set_allocated_deletenode(::message::DeleteNode* deletenode);

  // .message.AddToHashTable addToHashTable = 11;
  bool has_addtohashtable() const;
  void clear_addtohashtable();
  static const int kAddToHashTableFieldNumber = 11;
  const ::message::AddToHashTable& addtohashtable() const;
  ::message::AddToHashTable* release_addtohashtable();
  ::message::AddToHashTable* mutable_addtohashtable();
  void set_allocated_addtohashtable(::message::AddToHashTable* addtohashtable);

  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:message.Message)
 private:
  void set_has_joinmemsg();
  void set_has_joinmsg();
  void set_has_getvalmsg();
  void set_has_setvalmsg();
  void set_has_routingupdate();
  void set_has_allstateupdate();
  void set_has_getvalresponse();
  void set_has_deletenode();
  void set_has_addtohashtable();

  inline bool has_msg() const;
  void clear_msg();
  inline void clear_has_msg();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::message::Node* sender_;
  union MsgUnion {
    MsgUnion() {}
    ::message::JoinMe* joinmemsg_;
    ::message::Join* joinmsg_;
    ::message::GetVal* getvalmsg_;
    ::message::SetVal* setvalmsg_;
    ::message::RoutingUpdate* routingupdate_;
    ::message::AllStateUpdate* allstateupdate_;
    ::message::GetValResponse* getvalresponse_;
    ::message::DeleteNode* deletenode_;
    ::message::AddToHashTable* addtohashtable_;
  } msg_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsMessageImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:message.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsResponseImpl();
};
// -------------------------------------------------------------------

class DeleteNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.DeleteNode) */ {
 public:
  DeleteNode();
  virtual ~DeleteNode();

  DeleteNode(const DeleteNode& from);

  inline DeleteNode& operator=(const DeleteNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteNode(DeleteNode&& from) noexcept
    : DeleteNode() {
    *this = ::std::move(from);
  }

  inline DeleteNode& operator=(DeleteNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteNode* internal_default_instance() {
    return reinterpret_cast<const DeleteNode*>(
               &_DeleteNode_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(DeleteNode* other);
  friend void swap(DeleteNode& a, DeleteNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteNode* New() const PROTOBUF_FINAL { return New(NULL); }

  DeleteNode* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DeleteNode& from);
  void MergeFrom(const DeleteNode& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DeleteNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .message.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::message::Node& node() const;
  ::message::Node* release_node();
  ::message::Node* mutable_node();
  void set_allocated_node(::message::Node* node);

  // @@protoc_insertion_point(class_scope:message.DeleteNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::message::Node* node_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsDeleteNodeImpl();
};
// -------------------------------------------------------------------

class AddToHashTable_HashMapEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AddToHashTable_HashMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AddToHashTable_HashMapEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  AddToHashTable_HashMapEntry_DoNotUse();
  AddToHashTable_HashMapEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AddToHashTable_HashMapEntry_DoNotUse& other);
  static const AddToHashTable_HashMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AddToHashTable_HashMapEntry_DoNotUse*>(&_AddToHashTable_HashMapEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) PROTOBUF_FINAL;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AddToHashTable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:message.AddToHashTable) */ {
 public:
  AddToHashTable();
  virtual ~AddToHashTable();

  AddToHashTable(const AddToHashTable& from);

  inline AddToHashTable& operator=(const AddToHashTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddToHashTable(AddToHashTable&& from) noexcept
    : AddToHashTable() {
    *this = ::std::move(from);
  }

  inline AddToHashTable& operator=(AddToHashTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AddToHashTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddToHashTable* internal_default_instance() {
    return reinterpret_cast<const AddToHashTable*>(
               &_AddToHashTable_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(AddToHashTable* other);
  friend void swap(AddToHashTable& a, AddToHashTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddToHashTable* New() const PROTOBUF_FINAL { return New(NULL); }

  AddToHashTable* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AddToHashTable& from);
  void MergeFrom(const AddToHashTable& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AddToHashTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> hashMap = 1;
  int hashmap_size() const;
  void clear_hashmap();
  static const int kHashMapFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      hashmap() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_hashmap();

  // @@protoc_insertion_point(class_scope:message.AddToHashTable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      AddToHashTable_HashMapEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > hashmap_;
  mutable int _cached_size_;
  friend struct ::protobuf_message_2eproto::TableStruct;
  friend void ::protobuf_message_2eproto::InitDefaultsAddToHashTableImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JoinMe

// string nodeID = 1;
inline void JoinMe::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::nodeid() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.nodeID)
  return nodeid_.GetNoArena();
}
inline void JoinMe::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.nodeID)
}
#if LANG_CXX11
inline void JoinMe::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.nodeID)
}
#endif
inline void JoinMe::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.nodeID)
}
inline void JoinMe::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.nodeID)
}
inline ::std::string* JoinMe::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.JoinMe.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.nodeID)
}

// string IP = 2;
inline void JoinMe::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::ip() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.IP)
  return ip_.GetNoArena();
}
inline void JoinMe::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.IP)
}
#if LANG_CXX11
inline void JoinMe::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.IP)
}
#endif
inline void JoinMe::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.IP)
}
inline void JoinMe::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.IP)
}
inline ::std::string* JoinMe::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_ip() {
  // @@protoc_insertion_point(field_release:message.JoinMe.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.IP)
}

// string port = 3;
inline void JoinMe::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JoinMe::port() const {
  // @@protoc_insertion_point(field_get:message.JoinMe.port)
  return port_.GetNoArena();
}
inline void JoinMe::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.JoinMe.port)
}
#if LANG_CXX11
inline void JoinMe::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.JoinMe.port)
}
#endif
inline void JoinMe::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.JoinMe.port)
}
inline void JoinMe::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.JoinMe.port)
}
inline ::std::string* JoinMe::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.JoinMe.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JoinMe::release_port() {
  // @@protoc_insertion_point(field_release:message.JoinMe.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JoinMe::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.JoinMe.port)
}

// -------------------------------------------------------------------

// Join

// string nodeID = 1;
inline void Join::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::nodeid() const {
  // @@protoc_insertion_point(field_get:message.Join.nodeID)
  return nodeid_.GetNoArena();
}
inline void Join::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.nodeID)
}
#if LANG_CXX11
inline void Join::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.nodeID)
}
#endif
inline void Join::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.nodeID)
}
inline void Join::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.nodeID)
}
inline ::std::string* Join::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.Join.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.Join.nodeID)
}

// string IP = 2;
inline void Join::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::ip() const {
  // @@protoc_insertion_point(field_get:message.Join.IP)
  return ip_.GetNoArena();
}
inline void Join::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.IP)
}
#if LANG_CXX11
inline void Join::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.IP)
}
#endif
inline void Join::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.IP)
}
inline void Join::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.IP)
}
inline ::std::string* Join::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_ip() {
  // @@protoc_insertion_point(field_release:message.Join.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.Join.IP)
}

// string port = 3;
inline void Join::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Join::port() const {
  // @@protoc_insertion_point(field_get:message.Join.port)
  return port_.GetNoArena();
}
inline void Join::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Join.port)
}
#if LANG_CXX11
inline void Join::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Join.port)
}
#endif
inline void Join::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Join.port)
}
inline void Join::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Join.port)
}
inline ::std::string* Join::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.Join.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Join::release_port() {
  // @@protoc_insertion_point(field_release:message.Join.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Join::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.Join.port)
}

// int32 row_index = 4;
inline void Join::clear_row_index() {
  row_index_ = 0;
}
inline ::google::protobuf::int32 Join::row_index() const {
  // @@protoc_insertion_point(field_get:message.Join.row_index)
  return row_index_;
}
inline void Join::set_row_index(::google::protobuf::int32 value) {
  
  row_index_ = value;
  // @@protoc_insertion_point(field_set:message.Join.row_index)
}

// -------------------------------------------------------------------

// Node

// string nodeID = 1;
inline void Node::clear_nodeid() {
  nodeid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::nodeid() const {
  // @@protoc_insertion_point(field_get:message.Node.nodeID)
  return nodeid_.GetNoArena();
}
inline void Node::set_nodeid(const ::std::string& value) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.nodeID)
}
#if LANG_CXX11
inline void Node::set_nodeid(::std::string&& value) {
  
  nodeid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.nodeID)
}
#endif
inline void Node::set_nodeid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.nodeID)
}
inline void Node::set_nodeid(const char* value, size_t size) {
  
  nodeid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.nodeID)
}
inline ::std::string* Node::mutable_nodeid() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.nodeID)
  return nodeid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_nodeid() {
  // @@protoc_insertion_point(field_release:message.Node.nodeID)
  
  return nodeid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_nodeid(::std::string* nodeid) {
  if (nodeid != NULL) {
    
  } else {
    
  }
  nodeid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nodeid);
  // @@protoc_insertion_point(field_set_allocated:message.Node.nodeID)
}

// string IP = 2;
inline void Node::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::ip() const {
  // @@protoc_insertion_point(field_get:message.Node.IP)
  return ip_.GetNoArena();
}
inline void Node::set_ip(const ::std::string& value) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.IP)
}
#if LANG_CXX11
inline void Node::set_ip(::std::string&& value) {
  
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.IP)
}
#endif
inline void Node::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.IP)
}
inline void Node::set_ip(const char* value, size_t size) {
  
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.IP)
}
inline ::std::string* Node::mutable_ip() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.IP)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_ip() {
  // @@protoc_insertion_point(field_release:message.Node.IP)
  
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    
  } else {
    
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:message.Node.IP)
}

// string port = 3;
inline void Node::clear_port() {
  port_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::port() const {
  // @@protoc_insertion_point(field_get:message.Node.port)
  return port_.GetNoArena();
}
inline void Node::set_port(const ::std::string& value) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Node.port)
}
#if LANG_CXX11
inline void Node::set_port(::std::string&& value) {
  
  port_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Node.port)
}
#endif
inline void Node::set_port(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Node.port)
}
inline void Node::set_port(const char* value, size_t size) {
  
  port_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Node.port)
}
inline ::std::string* Node::mutable_port() {
  
  // @@protoc_insertion_point(field_mutable:message.Node.port)
  return port_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_port() {
  // @@protoc_insertion_point(field_release:message.Node.port)
  
  return port_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_port(::std::string* port) {
  if (port != NULL) {
    
  } else {
    
  }
  port_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port);
  // @@protoc_insertion_point(field_set_allocated:message.Node.port)
}

// -------------------------------------------------------------------

// List

// repeated .message.Node node = 1;
inline int List::node_size() const {
  return node_.size();
}
inline void List::clear_node() {
  node_.Clear();
}
inline const ::message::Node& List::node(int index) const {
  // @@protoc_insertion_point(field_get:message.List.node)
  return node_.Get(index);
}
inline ::message::Node* List::mutable_node(int index) {
  // @@protoc_insertion_point(field_mutable:message.List.node)
  return node_.Mutable(index);
}
inline ::message::Node* List::add_node() {
  // @@protoc_insertion_point(field_add:message.List.node)
  return node_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::Node >*
List::mutable_node() {
  // @@protoc_insertion_point(field_mutable_list:message.List.node)
  return &node_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::Node >&
List::node() const {
  // @@protoc_insertion_point(field_list:message.List.node)
  return node_;
}

// -------------------------------------------------------------------

// RoutingUpdate_RoutingEntry

// int32 index = 1;
inline void RoutingUpdate_RoutingEntry::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 RoutingUpdate_RoutingEntry::index() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.RoutingEntry.index)
  return index_;
}
inline void RoutingUpdate_RoutingEntry::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.RoutingEntry.index)
}

// .message.List nodeList = 2;
inline bool RoutingUpdate_RoutingEntry::has_nodelist() const {
  return this != internal_default_instance() && nodelist_ != NULL;
}
inline void RoutingUpdate_RoutingEntry::clear_nodelist() {
  if (GetArenaNoVirtual() == NULL && nodelist_ != NULL) {
    delete nodelist_;
  }
  nodelist_ = NULL;
}
inline const ::message::List& RoutingUpdate_RoutingEntry::nodelist() const {
  const ::message::List* p = nodelist_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.RoutingEntry.nodeList)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate_RoutingEntry::release_nodelist() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.RoutingEntry.nodeList)
  
  ::message::List* temp = nodelist_;
  nodelist_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate_RoutingEntry::mutable_nodelist() {
  
  if (nodelist_ == NULL) {
    nodelist_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.RoutingEntry.nodeList)
  return nodelist_;
}
inline void RoutingUpdate_RoutingEntry::set_allocated_nodelist(::message::List* nodelist) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete nodelist_;
  }
  if (nodelist) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      nodelist = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nodelist, submessage_arena);
    }
    
  } else {
    
  }
  nodelist_ = nodelist;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.RoutingEntry.nodeList)
}

// -------------------------------------------------------------------

// RoutingUpdate

// bool buddy = 1;
inline void RoutingUpdate::clear_buddy() {
  buddy_ = false;
}
inline bool RoutingUpdate::buddy() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.buddy)
  return buddy_;
}
inline void RoutingUpdate::set_buddy(bool value) {
  
  buddy_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.buddy)
}

// bool terminal = 2;
inline void RoutingUpdate::clear_terminal() {
  terminal_ = false;
}
inline bool RoutingUpdate::terminal() const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.terminal)
  return terminal_;
}
inline void RoutingUpdate::set_terminal(bool value) {
  
  terminal_ = value;
  // @@protoc_insertion_point(field_set:message.RoutingUpdate.terminal)
}

// .message.List leaf = 3;
inline bool RoutingUpdate::has_leaf() const {
  return this != internal_default_instance() && leaf_ != NULL;
}
inline void RoutingUpdate::clear_leaf() {
  if (GetArenaNoVirtual() == NULL && leaf_ != NULL) {
    delete leaf_;
  }
  leaf_ = NULL;
}
inline const ::message::List& RoutingUpdate::leaf() const {
  const ::message::List* p = leaf_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.leaf)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate::release_leaf() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.leaf)
  
  ::message::List* temp = leaf_;
  leaf_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate::mutable_leaf() {
  
  if (leaf_ == NULL) {
    leaf_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.leaf)
  return leaf_;
}
inline void RoutingUpdate::set_allocated_leaf(::message::List* leaf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leaf_;
  }
  if (leaf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leaf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    
  } else {
    
  }
  leaf_ = leaf;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.leaf)
}

// .message.List neighbours = 4;
inline bool RoutingUpdate::has_neighbours() const {
  return this != internal_default_instance() && neighbours_ != NULL;
}
inline void RoutingUpdate::clear_neighbours() {
  if (GetArenaNoVirtual() == NULL && neighbours_ != NULL) {
    delete neighbours_;
  }
  neighbours_ = NULL;
}
inline const ::message::List& RoutingUpdate::neighbours() const {
  const ::message::List* p = neighbours_;
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.neighbours)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* RoutingUpdate::release_neighbours() {
  // @@protoc_insertion_point(field_release:message.RoutingUpdate.neighbours)
  
  ::message::List* temp = neighbours_;
  neighbours_ = NULL;
  return temp;
}
inline ::message::List* RoutingUpdate::mutable_neighbours() {
  
  if (neighbours_ == NULL) {
    neighbours_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.neighbours)
  return neighbours_;
}
inline void RoutingUpdate::set_allocated_neighbours(::message::List* neighbours) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbours_;
  }
  if (neighbours) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbours = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbours, submessage_arena);
    }
    
  } else {
    
  }
  neighbours_ = neighbours;
  // @@protoc_insertion_point(field_set_allocated:message.RoutingUpdate.neighbours)
}

// repeated .message.RoutingUpdate.RoutingEntry routingEntires = 5;
inline int RoutingUpdate::routingentires_size() const {
  return routingentires_.size();
}
inline void RoutingUpdate::clear_routingentires() {
  routingentires_.Clear();
}
inline const ::message::RoutingUpdate_RoutingEntry& RoutingUpdate::routingentires(int index) const {
  // @@protoc_insertion_point(field_get:message.RoutingUpdate.routingEntires)
  return routingentires_.Get(index);
}
inline ::message::RoutingUpdate_RoutingEntry* RoutingUpdate::mutable_routingentires(int index) {
  // @@protoc_insertion_point(field_mutable:message.RoutingUpdate.routingEntires)
  return routingentires_.Mutable(index);
}
inline ::message::RoutingUpdate_RoutingEntry* RoutingUpdate::add_routingentires() {
  // @@protoc_insertion_point(field_add:message.RoutingUpdate.routingEntires)
  return routingentires_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >*
RoutingUpdate::mutable_routingentires() {
  // @@protoc_insertion_point(field_mutable_list:message.RoutingUpdate.routingEntires)
  return &routingentires_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::RoutingUpdate_RoutingEntry >&
RoutingUpdate::routingentires() const {
  // @@protoc_insertion_point(field_list:message.RoutingUpdate.routingEntires)
  return routingentires_;
}

// -------------------------------------------------------------------

// AllStateUpdate

// .message.List leaf = 1;
inline bool AllStateUpdate::has_leaf() const {
  return this != internal_default_instance() && leaf_ != NULL;
}
inline void AllStateUpdate::clear_leaf() {
  if (GetArenaNoVirtual() == NULL && leaf_ != NULL) {
    delete leaf_;
  }
  leaf_ = NULL;
}
inline const ::message::List& AllStateUpdate::leaf() const {
  const ::message::List* p = leaf_;
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.leaf)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* AllStateUpdate::release_leaf() {
  // @@protoc_insertion_point(field_release:message.AllStateUpdate.leaf)
  
  ::message::List* temp = leaf_;
  leaf_ = NULL;
  return temp;
}
inline ::message::List* AllStateUpdate::mutable_leaf() {
  
  if (leaf_ == NULL) {
    leaf_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.leaf)
  return leaf_;
}
inline void AllStateUpdate::set_allocated_leaf(::message::List* leaf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete leaf_;
  }
  if (leaf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      leaf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, leaf, submessage_arena);
    }
    
  } else {
    
  }
  leaf_ = leaf;
  // @@protoc_insertion_point(field_set_allocated:message.AllStateUpdate.leaf)
}

// repeated .message.List routingTable = 2;
inline int AllStateUpdate::routingtable_size() const {
  return routingtable_.size();
}
inline void AllStateUpdate::clear_routingtable() {
  routingtable_.Clear();
}
inline const ::message::List& AllStateUpdate::routingtable(int index) const {
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.routingTable)
  return routingtable_.Get(index);
}
inline ::message::List* AllStateUpdate::mutable_routingtable(int index) {
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.routingTable)
  return routingtable_.Mutable(index);
}
inline ::message::List* AllStateUpdate::add_routingtable() {
  // @@protoc_insertion_point(field_add:message.AllStateUpdate.routingTable)
  return routingtable_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::message::List >*
AllStateUpdate::mutable_routingtable() {
  // @@protoc_insertion_point(field_mutable_list:message.AllStateUpdate.routingTable)
  return &routingtable_;
}
inline const ::google::protobuf::RepeatedPtrField< ::message::List >&
AllStateUpdate::routingtable() const {
  // @@protoc_insertion_point(field_list:message.AllStateUpdate.routingTable)
  return routingtable_;
}

// .message.List neighbours = 3;
inline bool AllStateUpdate::has_neighbours() const {
  return this != internal_default_instance() && neighbours_ != NULL;
}
inline void AllStateUpdate::clear_neighbours() {
  if (GetArenaNoVirtual() == NULL && neighbours_ != NULL) {
    delete neighbours_;
  }
  neighbours_ = NULL;
}
inline const ::message::List& AllStateUpdate::neighbours() const {
  const ::message::List* p = neighbours_;
  // @@protoc_insertion_point(field_get:message.AllStateUpdate.neighbours)
  return p != NULL ? *p : *reinterpret_cast<const ::message::List*>(
      &::message::_List_default_instance_);
}
inline ::message::List* AllStateUpdate::release_neighbours() {
  // @@protoc_insertion_point(field_release:message.AllStateUpdate.neighbours)
  
  ::message::List* temp = neighbours_;
  neighbours_ = NULL;
  return temp;
}
inline ::message::List* AllStateUpdate::mutable_neighbours() {
  
  if (neighbours_ == NULL) {
    neighbours_ = new ::message::List;
  }
  // @@protoc_insertion_point(field_mutable:message.AllStateUpdate.neighbours)
  return neighbours_;
}
inline void AllStateUpdate::set_allocated_neighbours(::message::List* neighbours) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbours_;
  }
  if (neighbours) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbours = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbours, submessage_arena);
    }
    
  } else {
    
  }
  neighbours_ = neighbours;
  // @@protoc_insertion_point(field_set_allocated:message.AllStateUpdate.neighbours)
}

// -------------------------------------------------------------------

// GetVal

// string key = 1;
inline void GetVal::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetVal::key() const {
  // @@protoc_insertion_point(field_get:message.GetVal.key)
  return key_.GetNoArena();
}
inline void GetVal::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.GetVal.key)
}
#if LANG_CXX11
inline void GetVal::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.GetVal.key)
}
#endif
inline void GetVal::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.GetVal.key)
}
inline void GetVal::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.GetVal.key)
}
inline ::std::string* GetVal::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:message.GetVal.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetVal::release_key() {
  // @@protoc_insertion_point(field_release:message.GetVal.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetVal::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:message.GetVal.key)
}

// .message.Node node = 2;
inline bool GetVal::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void GetVal::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) {
    delete node_;
  }
  node_ = NULL;
}
inline const ::message::Node& GetVal::node() const {
  const ::message::Node* p = node_;
  // @@protoc_insertion_point(field_get:message.GetVal.node)
  return p != NULL ? *p : *reinterpret_cast<const ::message::Node*>(
      &::message::_Node_default_instance_);
}
inline ::message::Node* GetVal::release_node() {
  // @@protoc_insertion_point(field_release:message.GetVal.node)
  
  ::message::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::message::Node* GetVal::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::message::Node;
  }
  // @@protoc_insertion_point(field_mutable:message.GetVal.node)
  return node_;
}
inline void GetVal::set_allocated_node(::message::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:message.GetVal.node)
}

// -------------------------------------------------------------------

// GetValResponse

// string key = 1;
inline void GetValResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetValResponse::key() const {
  // @@protoc_insertion_point(field_get:message.GetValResponse.key)
  return key_.GetNoArena();
}
inline void GetValResponse::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.GetValResponse.key)
}
#if LANG_CXX11
inline void GetValResponse::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.GetValResponse.key)
}
#endif
inline void GetValResponse::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.GetValResponse.key)
}
inline void GetValResponse::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.GetValResponse.key)
}
inline ::std::string* GetValResponse::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:message.GetValResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetValResponse::release_key() {
  // @@protoc_insertion_point(field_release:message.GetValResponse.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetValResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:message.GetValResponse.key)
}

// string value = 2;
inline void GetValResponse::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetValResponse::value() const {
  // @@protoc_insertion_point(field_get:message.GetValResponse.value)
  return value_.GetNoArena();
}
inline void GetValResponse::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.GetValResponse.value)
}
#if LANG_CXX11
inline void GetValResponse::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.GetValResponse.value)
}
#endif
inline void GetValResponse::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.GetValResponse.value)
}
inline void GetValResponse::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.GetValResponse.value)
}
inline ::std::string* GetValResponse::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:message.GetValResponse.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetValResponse::release_value() {
  // @@protoc_insertion_point(field_release:message.GetValResponse.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetValResponse::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:message.GetValResponse.value)
}

// -------------------------------------------------------------------

// SetVal

// string key = 1;
inline void SetVal::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetVal::key() const {
  // @@protoc_insertion_point(field_get:message.SetVal.key)
  return key_.GetNoArena();
}
inline void SetVal::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.SetVal.key)
}
#if LANG_CXX11
inline void SetVal::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.SetVal.key)
}
#endif
inline void SetVal::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.SetVal.key)
}
inline void SetVal::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.SetVal.key)
}
inline ::std::string* SetVal::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:message.SetVal.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetVal::release_key() {
  // @@protoc_insertion_point(field_release:message.SetVal.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetVal::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:message.SetVal.key)
}

// string val = 2;
inline void SetVal::clear_val() {
  val_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SetVal::val() const {
  // @@protoc_insertion_point(field_get:message.SetVal.val)
  return val_.GetNoArena();
}
inline void SetVal::set_val(const ::std::string& value) {
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.SetVal.val)
}
#if LANG_CXX11
inline void SetVal::set_val(::std::string&& value) {
  
  val_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.SetVal.val)
}
#endif
inline void SetVal::set_val(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.SetVal.val)
}
inline void SetVal::set_val(const char* value, size_t size) {
  
  val_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.SetVal.val)
}
inline ::std::string* SetVal::mutable_val() {
  
  // @@protoc_insertion_point(field_mutable:message.SetVal.val)
  return val_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetVal::release_val() {
  // @@protoc_insertion_point(field_release:message.SetVal.val)
  
  return val_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetVal::set_allocated_val(::std::string* val) {
  if (val != NULL) {
    
  } else {
    
  }
  val_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), val);
  // @@protoc_insertion_point(field_set_allocated:message.SetVal.val)
}

// .message.Node node = 3;
inline bool SetVal::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void SetVal::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) {
    delete node_;
  }
  node_ = NULL;
}
inline const ::message::Node& SetVal::node() const {
  const ::message::Node* p = node_;
  // @@protoc_insertion_point(field_get:message.SetVal.node)
  return p != NULL ? *p : *reinterpret_cast<const ::message::Node*>(
      &::message::_Node_default_instance_);
}
inline ::message::Node* SetVal::release_node() {
  // @@protoc_insertion_point(field_release:message.SetVal.node)
  
  ::message::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::message::Node* SetVal::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::message::Node;
  }
  // @@protoc_insertion_point(field_mutable:message.SetVal.node)
  return node_;
}
inline void SetVal::set_allocated_node(::message::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:message.SetVal.node)
}

// bool terminal = 4;
inline void SetVal::clear_terminal() {
  terminal_ = false;
}
inline bool SetVal::terminal() const {
  // @@protoc_insertion_point(field_get:message.SetVal.terminal)
  return terminal_;
}
inline void SetVal::set_terminal(bool value) {
  
  terminal_ = value;
  // @@protoc_insertion_point(field_set:message.SetVal.terminal)
}

// -------------------------------------------------------------------

// Message

// string type = 1;
inline void Message::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Message::type() const {
  // @@protoc_insertion_point(field_get:message.Message.type)
  return type_.GetNoArena();
}
inline void Message::set_type(const ::std::string& value) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Message.type)
}
#if LANG_CXX11
inline void Message::set_type(::std::string&& value) {
  
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Message.type)
}
#endif
inline void Message::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Message.type)
}
inline void Message::set_type(const char* value, size_t size) {
  
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Message.type)
}
inline ::std::string* Message::mutable_type() {
  
  // @@protoc_insertion_point(field_mutable:message.Message.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Message::release_type() {
  // @@protoc_insertion_point(field_release:message.Message.type)
  
  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Message::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    
  } else {
    
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:message.Message.type)
}

// .message.Node sender = 2;
inline bool Message::has_sender() const {
  return this != internal_default_instance() && sender_ != NULL;
}
inline void Message::clear_sender() {
  if (GetArenaNoVirtual() == NULL && sender_ != NULL) {
    delete sender_;
  }
  sender_ = NULL;
}
inline const ::message::Node& Message::sender() const {
  const ::message::Node* p = sender_;
  // @@protoc_insertion_point(field_get:message.Message.sender)
  return p != NULL ? *p : *reinterpret_cast<const ::message::Node*>(
      &::message::_Node_default_instance_);
}
inline ::message::Node* Message::release_sender() {
  // @@protoc_insertion_point(field_release:message.Message.sender)
  
  ::message::Node* temp = sender_;
  sender_ = NULL;
  return temp;
}
inline ::message::Node* Message::mutable_sender() {
  
  if (sender_ == NULL) {
    sender_ = new ::message::Node;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.sender)
  return sender_;
}
inline void Message::set_allocated_sender(::message::Node* sender) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sender_;
  }
  if (sender) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sender = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:message.Message.sender)
}

// .message.JoinMe joinMeMsg = 3;
inline bool Message::has_joinmemsg() const {
  return msg_case() == kJoinMeMsg;
}
inline void Message::set_has_joinmemsg() {
  _oneof_case_[0] = kJoinMeMsg;
}
inline void Message::clear_joinmemsg() {
  if (has_joinmemsg()) {
    delete msg_.joinmemsg_;
    clear_has_msg();
  }
}
inline ::message::JoinMe* Message::release_joinmemsg() {
  // @@protoc_insertion_point(field_release:message.Message.joinMeMsg)
  if (has_joinmemsg()) {
    clear_has_msg();
      ::message::JoinMe* temp = msg_.joinmemsg_;
    msg_.joinmemsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::JoinMe& Message::joinmemsg() const {
  // @@protoc_insertion_point(field_get:message.Message.joinMeMsg)
  return has_joinmemsg()
      ? *msg_.joinmemsg_
      : *reinterpret_cast< ::message::JoinMe*>(&::message::_JoinMe_default_instance_);
}
inline ::message::JoinMe* Message::mutable_joinmemsg() {
  if (!has_joinmemsg()) {
    clear_msg();
    set_has_joinmemsg();
    msg_.joinmemsg_ = new ::message::JoinMe;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.joinMeMsg)
  return msg_.joinmemsg_;
}

// .message.Join joinMsg = 4;
inline bool Message::has_joinmsg() const {
  return msg_case() == kJoinMsg;
}
inline void Message::set_has_joinmsg() {
  _oneof_case_[0] = kJoinMsg;
}
inline void Message::clear_joinmsg() {
  if (has_joinmsg()) {
    delete msg_.joinmsg_;
    clear_has_msg();
  }
}
inline ::message::Join* Message::release_joinmsg() {
  // @@protoc_insertion_point(field_release:message.Message.joinMsg)
  if (has_joinmsg()) {
    clear_has_msg();
      ::message::Join* temp = msg_.joinmsg_;
    msg_.joinmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::Join& Message::joinmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.joinMsg)
  return has_joinmsg()
      ? *msg_.joinmsg_
      : *reinterpret_cast< ::message::Join*>(&::message::_Join_default_instance_);
}
inline ::message::Join* Message::mutable_joinmsg() {
  if (!has_joinmsg()) {
    clear_msg();
    set_has_joinmsg();
    msg_.joinmsg_ = new ::message::Join;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.joinMsg)
  return msg_.joinmsg_;
}

// .message.GetVal getValMsg = 5;
inline bool Message::has_getvalmsg() const {
  return msg_case() == kGetValMsg;
}
inline void Message::set_has_getvalmsg() {
  _oneof_case_[0] = kGetValMsg;
}
inline void Message::clear_getvalmsg() {
  if (has_getvalmsg()) {
    delete msg_.getvalmsg_;
    clear_has_msg();
  }
}
inline ::message::GetVal* Message::release_getvalmsg() {
  // @@protoc_insertion_point(field_release:message.Message.getValMsg)
  if (has_getvalmsg()) {
    clear_has_msg();
      ::message::GetVal* temp = msg_.getvalmsg_;
    msg_.getvalmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::GetVal& Message::getvalmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.getValMsg)
  return has_getvalmsg()
      ? *msg_.getvalmsg_
      : *reinterpret_cast< ::message::GetVal*>(&::message::_GetVal_default_instance_);
}
inline ::message::GetVal* Message::mutable_getvalmsg() {
  if (!has_getvalmsg()) {
    clear_msg();
    set_has_getvalmsg();
    msg_.getvalmsg_ = new ::message::GetVal;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.getValMsg)
  return msg_.getvalmsg_;
}

// .message.SetVal setValMsg = 6;
inline bool Message::has_setvalmsg() const {
  return msg_case() == kSetValMsg;
}
inline void Message::set_has_setvalmsg() {
  _oneof_case_[0] = kSetValMsg;
}
inline void Message::clear_setvalmsg() {
  if (has_setvalmsg()) {
    delete msg_.setvalmsg_;
    clear_has_msg();
  }
}
inline ::message::SetVal* Message::release_setvalmsg() {
  // @@protoc_insertion_point(field_release:message.Message.setValMsg)
  if (has_setvalmsg()) {
    clear_has_msg();
      ::message::SetVal* temp = msg_.setvalmsg_;
    msg_.setvalmsg_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::SetVal& Message::setvalmsg() const {
  // @@protoc_insertion_point(field_get:message.Message.setValMsg)
  return has_setvalmsg()
      ? *msg_.setvalmsg_
      : *reinterpret_cast< ::message::SetVal*>(&::message::_SetVal_default_instance_);
}
inline ::message::SetVal* Message::mutable_setvalmsg() {
  if (!has_setvalmsg()) {
    clear_msg();
    set_has_setvalmsg();
    msg_.setvalmsg_ = new ::message::SetVal;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.setValMsg)
  return msg_.setvalmsg_;
}

// .message.RoutingUpdate routingUpdate = 7;
inline bool Message::has_routingupdate() const {
  return msg_case() == kRoutingUpdate;
}
inline void Message::set_has_routingupdate() {
  _oneof_case_[0] = kRoutingUpdate;
}
inline void Message::clear_routingupdate() {
  if (has_routingupdate()) {
    delete msg_.routingupdate_;
    clear_has_msg();
  }
}
inline ::message::RoutingUpdate* Message::release_routingupdate() {
  // @@protoc_insertion_point(field_release:message.Message.routingUpdate)
  if (has_routingupdate()) {
    clear_has_msg();
      ::message::RoutingUpdate* temp = msg_.routingupdate_;
    msg_.routingupdate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::RoutingUpdate& Message::routingupdate() const {
  // @@protoc_insertion_point(field_get:message.Message.routingUpdate)
  return has_routingupdate()
      ? *msg_.routingupdate_
      : *reinterpret_cast< ::message::RoutingUpdate*>(&::message::_RoutingUpdate_default_instance_);
}
inline ::message::RoutingUpdate* Message::mutable_routingupdate() {
  if (!has_routingupdate()) {
    clear_msg();
    set_has_routingupdate();
    msg_.routingupdate_ = new ::message::RoutingUpdate;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.routingUpdate)
  return msg_.routingupdate_;
}

// .message.AllStateUpdate allStateUpdate = 8;
inline bool Message::has_allstateupdate() const {
  return msg_case() == kAllStateUpdate;
}
inline void Message::set_has_allstateupdate() {
  _oneof_case_[0] = kAllStateUpdate;
}
inline void Message::clear_allstateupdate() {
  if (has_allstateupdate()) {
    delete msg_.allstateupdate_;
    clear_has_msg();
  }
}
inline ::message::AllStateUpdate* Message::release_allstateupdate() {
  // @@protoc_insertion_point(field_release:message.Message.allStateUpdate)
  if (has_allstateupdate()) {
    clear_has_msg();
      ::message::AllStateUpdate* temp = msg_.allstateupdate_;
    msg_.allstateupdate_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::AllStateUpdate& Message::allstateupdate() const {
  // @@protoc_insertion_point(field_get:message.Message.allStateUpdate)
  return has_allstateupdate()
      ? *msg_.allstateupdate_
      : *reinterpret_cast< ::message::AllStateUpdate*>(&::message::_AllStateUpdate_default_instance_);
}
inline ::message::AllStateUpdate* Message::mutable_allstateupdate() {
  if (!has_allstateupdate()) {
    clear_msg();
    set_has_allstateupdate();
    msg_.allstateupdate_ = new ::message::AllStateUpdate;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.allStateUpdate)
  return msg_.allstateupdate_;
}

// .message.GetValResponse getValResponse = 9;
inline bool Message::has_getvalresponse() const {
  return msg_case() == kGetValResponse;
}
inline void Message::set_has_getvalresponse() {
  _oneof_case_[0] = kGetValResponse;
}
inline void Message::clear_getvalresponse() {
  if (has_getvalresponse()) {
    delete msg_.getvalresponse_;
    clear_has_msg();
  }
}
inline ::message::GetValResponse* Message::release_getvalresponse() {
  // @@protoc_insertion_point(field_release:message.Message.getValResponse)
  if (has_getvalresponse()) {
    clear_has_msg();
      ::message::GetValResponse* temp = msg_.getvalresponse_;
    msg_.getvalresponse_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::GetValResponse& Message::getvalresponse() const {
  // @@protoc_insertion_point(field_get:message.Message.getValResponse)
  return has_getvalresponse()
      ? *msg_.getvalresponse_
      : *reinterpret_cast< ::message::GetValResponse*>(&::message::_GetValResponse_default_instance_);
}
inline ::message::GetValResponse* Message::mutable_getvalresponse() {
  if (!has_getvalresponse()) {
    clear_msg();
    set_has_getvalresponse();
    msg_.getvalresponse_ = new ::message::GetValResponse;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.getValResponse)
  return msg_.getvalresponse_;
}

// .message.DeleteNode deleteNode = 10;
inline bool Message::has_deletenode() const {
  return msg_case() == kDeleteNode;
}
inline void Message::set_has_deletenode() {
  _oneof_case_[0] = kDeleteNode;
}
inline void Message::clear_deletenode() {
  if (has_deletenode()) {
    delete msg_.deletenode_;
    clear_has_msg();
  }
}
inline ::message::DeleteNode* Message::release_deletenode() {
  // @@protoc_insertion_point(field_release:message.Message.deleteNode)
  if (has_deletenode()) {
    clear_has_msg();
      ::message::DeleteNode* temp = msg_.deletenode_;
    msg_.deletenode_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::DeleteNode& Message::deletenode() const {
  // @@protoc_insertion_point(field_get:message.Message.deleteNode)
  return has_deletenode()
      ? *msg_.deletenode_
      : *reinterpret_cast< ::message::DeleteNode*>(&::message::_DeleteNode_default_instance_);
}
inline ::message::DeleteNode* Message::mutable_deletenode() {
  if (!has_deletenode()) {
    clear_msg();
    set_has_deletenode();
    msg_.deletenode_ = new ::message::DeleteNode;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.deleteNode)
  return msg_.deletenode_;
}

// .message.AddToHashTable addToHashTable = 11;
inline bool Message::has_addtohashtable() const {
  return msg_case() == kAddToHashTable;
}
inline void Message::set_has_addtohashtable() {
  _oneof_case_[0] = kAddToHashTable;
}
inline void Message::clear_addtohashtable() {
  if (has_addtohashtable()) {
    delete msg_.addtohashtable_;
    clear_has_msg();
  }
}
inline ::message::AddToHashTable* Message::release_addtohashtable() {
  // @@protoc_insertion_point(field_release:message.Message.addToHashTable)
  if (has_addtohashtable()) {
    clear_has_msg();
      ::message::AddToHashTable* temp = msg_.addtohashtable_;
    msg_.addtohashtable_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::message::AddToHashTable& Message::addtohashtable() const {
  // @@protoc_insertion_point(field_get:message.Message.addToHashTable)
  return has_addtohashtable()
      ? *msg_.addtohashtable_
      : *reinterpret_cast< ::message::AddToHashTable*>(&::message::_AddToHashTable_default_instance_);
}
inline ::message::AddToHashTable* Message::mutable_addtohashtable() {
  if (!has_addtohashtable()) {
    clear_msg();
    set_has_addtohashtable();
    msg_.addtohashtable_ = new ::message::AddToHashTable;
  }
  // @@protoc_insertion_point(field_mutable:message.Message.addToHashTable)
  return msg_.addtohashtable_;
}

inline bool Message::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void Message::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline Message::MsgCase Message::msg_case() const {
  return Message::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Response

// string status = 1;
inline void Response::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Response::status() const {
  // @@protoc_insertion_point(field_get:message.Response.status)
  return status_.GetNoArena();
}
inline void Response::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message.Response.status)
}
#if LANG_CXX11
inline void Response::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message.Response.status)
}
#endif
inline void Response::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message.Response.status)
}
inline void Response::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message.Response.status)
}
inline ::std::string* Response::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:message.Response.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Response::release_status() {
  // @@protoc_insertion_point(field_release:message.Response.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Response::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:message.Response.status)
}

// -------------------------------------------------------------------

// DeleteNode

// .message.Node node = 1;
inline bool DeleteNode::has_node() const {
  return this != internal_default_instance() && node_ != NULL;
}
inline void DeleteNode::clear_node() {
  if (GetArenaNoVirtual() == NULL && node_ != NULL) {
    delete node_;
  }
  node_ = NULL;
}
inline const ::message::Node& DeleteNode::node() const {
  const ::message::Node* p = node_;
  // @@protoc_insertion_point(field_get:message.DeleteNode.node)
  return p != NULL ? *p : *reinterpret_cast<const ::message::Node*>(
      &::message::_Node_default_instance_);
}
inline ::message::Node* DeleteNode::release_node() {
  // @@protoc_insertion_point(field_release:message.DeleteNode.node)
  
  ::message::Node* temp = node_;
  node_ = NULL;
  return temp;
}
inline ::message::Node* DeleteNode::mutable_node() {
  
  if (node_ == NULL) {
    node_ = new ::message::Node;
  }
  // @@protoc_insertion_point(field_mutable:message.DeleteNode.node)
  return node_;
}
inline void DeleteNode::set_allocated_node(::message::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:message.DeleteNode.node)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AddToHashTable

// map<string, string> hashMap = 1;
inline int AddToHashTable::hashmap_size() const {
  return hashmap_.size();
}
inline void AddToHashTable::clear_hashmap() {
  hashmap_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
AddToHashTable::hashmap() const {
  // @@protoc_insertion_point(field_map:message.AddToHashTable.hashMap)
  return hashmap_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
AddToHashTable::mutable_hashmap() {
  // @@protoc_insertion_point(field_mutable_map:message.AddToHashTable.hashMap)
  return hashmap_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace message

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_message_2eproto__INCLUDED
